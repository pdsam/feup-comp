options {
  LOOKAHEAD = 1;
  MULTI = true;
}

PARSER_BEGIN(MyGrammar)
    import java.io.InputStream;
    import java.io.FileInputStream;

    // Java code invoking the parser
    public class MyGrammar{
        public static void main(String[] args) throws ParseException {
            if(args.length < 1) {
                System.out.println("Usage: java jmm [-r=<num>] [-o] <input_file.jmm>");
                return;
            } else if (!args[0].matches("(.*).jmm")) {
                System.out.println("Invalid file type: only .jmm files are accepted");
                return;
            }
            InputStream file = null;

            try {
                file = new FileInputStream(args[0]);
            } catch(Exception e) {
                System.out.println(e.getMessage());
                //e.printStackTrace();
                return;
            }

            MyGrammar parser = new MyGrammar(file);
            SimpleNode root = parser.Program();
            root.dump(">");
        }
    }
PARSER_END(MyGrammar)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
    " "
    | "\t" 
    | "\r"
    | "\n" 
    //skip comments of both types   
    |   <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
    |   <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

// token definition(terminal symbols)
TOKEN :
{
    <UNDERSCORE: "_" >
    |   <L_SBRACKET: "[" >
    |   <R_SBRACKET: "]" >
    |   <DOLLARSIGN: "$">
    |   <L_BRACKET: "{" >
    |   <R_BRACKET: "}" >
    |   <L_PAR: "(" >
    |   <R_PAR: ")" >
    |   <PLUS: "+" >
    |   <MINUS: "-" >
    |   <MUL: "*" >
    |   <DIV: "/" >
    |   <EQUAL: "=" >
    |   <COMMA : "," >
    |   <DOT : "." >
    |   <SEMICOLON : ";" >
    |   <NOT : "!" >
    |   <AND : "&&" >
    |   <LESS_THAN : "<" >
    |   <LENGTH : "length" >
    |   <CLASS : "class" >
    |   <THIS : "this" >
    |   <NEW : "new" >
    |   <EXTENDS : "extends" >
    |   <IMPORT : "import" >
    |   <STRING : "String" >
    |   <PUBLIC : "public" >
    |   <STATIC: "static">
    |   <MAIN: "main">
    |   <VOID: "void">
    |   <INT : "int" >
    |   <BOOL : "boolean" >
    |   <TRUE : "true" >
    |   <FALSE : "false" >
    |   <RETURN : "return" >
    |   <IF : "if" >
    |   <ELSE : "else" >
    |   <WHILE : "while" >
    |   <INTEGER_LITERAL: (<DIGIT>)+ >
    |   <IDENTIFIER: ((<LETTER> | <UNDERSCORE> | <DOLLARSIGN>) (<LETTER> | <DIGIT> | <UNDERSCORE> | <DOLLARSIGN>)*) >
    |   <DIGIT: (["0"-"9"]) >
    |   <LETTER: (["a"-"z","A"-"Z"]) >
}

// Production definition
SimpleNode Program() : {}
{
    (LOOKAHEAD(2) ImportDeclaration())*
    ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration() #void : { Token imported;}
{
    <IMPORT> (
        ClassImport()
        | StaticMethodImport()
    )
    <SEMICOLON>
}

void ClassImport() : {}
{
    <IDENTIFIER> (<DOT> <IDENTIFIER>)* (<L_PAR> (<VOID> | (Type() (<COMMA> Type())*))? <R_PAR> (Type() | <VOID>))?
}

void StaticMethodImport() #MethodImport : {}
{
    <STATIC> <IDENTIFIER> (<DOT> <IDENTIFIER>)+ <L_PAR> (<VOID> | (Type() (<COMMA> Type())*))? <R_PAR> (Type() | <VOID>)
}

void ClassDeclaration() #Class : {Token identifier, parent;}
{
    <CLASS> identifier=<IDENTIFIER> {jjtThis.identifier = identifier.image;}
        (<EXTENDS> parent=<IDENTIFIER> {jjtThis.parent = parent.image;})?
    <L_BRACKET>
        (VarDeclaration())* #VarDeclarationsList(true)
        (
            LOOKAHEAD(2)
            MethodDeclaration()
        )* #MethodList
        MainDeclaration()            // This forces 'main' to only appear once
        (MethodDeclaration())* #MethodList
    <R_BRACKET> 
}

void VarDeclaration() #Var : {String type; Token identifier;}
{
    type=Type() {jjtThis.type = type;} identifier=<IDENTIFIER> {jjtThis.identifier = identifier.image;} <SEMICOLON>
}

void MethodDeclaration() #Method : {String type; Token identifier;}
{
    <PUBLIC> type=Type() {jjtThis.type = type;} identifier=<IDENTIFIER>
        {jjtThis.identifier = identifier.image;}  <L_PAR> Arguments() <R_PAR>
    <L_BRACKET>
        (
            LOOKAHEAD(2)
            VarDeclaration()
        )* #VarDeclarationsList(true)
        (Statement())* #StatementList
        <RETURN> Expression() #ReturnStatement <SEMICOLON> // A return statement has to be the last thing in a method declaration
    <R_BRACKET>
}

void MainDeclaration() #MainMethod : {Token identifier;}
{
    <PUBLIC> <STATIC> <VOID> <MAIN> <L_PAR> (
        (<STRING> <L_SBRACKET> <R_SBRACKET> identifier=<IDENTIFIER>
            {jjtThis.identifier = identifier.image; jjtThis.type="String";})#Argument) #ArgumentList <R_PAR>
    <L_BRACKET>
        (LOOKAHEAD(2) VarDeclaration())* #VarDeclarationsList(true)
        (Statement())* #StatementList
    <R_BRACKET>
}

void Arguments() #ArgumentList : {}
{
    ( Argument() ( <COMMA> Argument())* )?
}

void Argument() #Argument : {Token identifier;String type;}
{
    type=Type() identifier=<IDENTIFIER> {jjtThis.identifier = identifier.image; jjtThis.type=type;}
}

String Type() #void : {String type; Token identifier;}
{
    (<INT> {type = "int";} (<L_SBRACKET> <R_SBRACKET> {type = "array";} )?
    | <BOOL> {type = "boolean";}
    | identifier=<IDENTIFIER> {type = identifier.image;})
    {return type;}
}

Statement Statement() #void : {Statement st;}
{
    (st = ScopedStatementList()
    |   st = IfElseStmt()
    |   st = WhileStmt()
    |   (
            LOOKAHEAD(2) st = Assignment()
            | LOOKAHEAD(2) st = IdSub()
            | st = ExprStatement()
        ))
    {return st;}
}

Statement ScopedStatementList() #ScopedStatementList : {}
{
    <L_BRACKET> (Statement())* <R_BRACKET>
    {return jjtThis;}
}

Statement Assignment() #Assignment : {Expression varRef, value;}
{
    varRef=VarReference() <EQUAL> value=Expression() <SEMICOLON>
    {
        jjtThis.varReference = varRef;
        jjtThis.value = value;
        return jjtThis;
    }
}

Statement IfElseStmt() #Branch : {Expression condition; Statement thenStatement, elseStatement;}
{
    <IF> <L_PAR> condition=Expression() <R_PAR>
        thenStatement=Statement()
    <ELSE>
        elseStatement=Statement()
    {
        jjtThis.condition = condition;
        jjtThis.thenStatement = thenStatement;
        jjtThis.elseStatement = elseStatement;
        return jjtThis;
    }
}

Statement WhileStmt() #WhileLoop : {Expression condition; Statement body;}
{
    <WHILE> <L_PAR> condition = Expression() <R_PAR>
        body = Statement()
    {
        jjtThis.condition = condition;
        jjtThis.body = body;
        return jjtThis;
    }
}

Statement IdSub() #void : {Expression e1; Statement st;} {
    e1=ArrayAccess() (
        st = ArrayAssignment(e1)
        | st = ArrayAccessExprStatement(e1)
    )

    {return st;}
}

Statement ArrayAssignment(Expression arrayRef) #ArrayAssignment(2) : {Expression value;}
{
    <EQUAL> value=Expression() <SEMICOLON>
    {
        jjtThis.arrayRef = arrayRef;
        jjtThis.value = value;
        return jjtThis;
    }
}

Statement ArrayAccessExprStatement(Expression arrayRef) #ExprStatement: {Expression e = null;}
{
    (e = Expr2(arrayRef))? <SEMICOLON>
    {jjtThis.expression = e == null ? arrayRef : e;}
    {return jjtThis;}
}

Statement ExprStatement() #ExprStatement : {Expression e;}
{
    e = Expression() <SEMICOLON>
    {jjtThis.expression = e;}
    {return jjtThis;}
}

Expression ArrayAccess() #ArrayAccess : {Token identifier; Expression index, arrRef;}
{
    arrRef=VarReference() <L_SBRACKET> index = Expression() <R_SBRACKET>
    {
        jjtThis.arrayRef = arrRef;
        jjtThis.index = index;
    }
    {return jjtThis;}
}

Expression Expression() #void : {Expression e, e2 = null;}
{
    e=Expr1() (LOOKAHEAD(2) e2=Expr2(e) )?
    {
        return e2 == null ? e : e2;
    }
}

Expression Expr1() #void : {Token identifier, value; Expression e;} {
    (e = Literal()
    | e = VarReference()
    | e =  SelfReference()
    |   (<NEW>  (
            e = ArrayCreation()
            | e = ConstructorCall()
        ))
    |   e = Negation()
    |   <L_PAR> e = Expression() <R_PAR>)

    {return e;}
}

Expression Literal() #Literal : {Token value;}
{
    (value = <INTEGER_LITERAL> {jjtThis.type = "int"; jjtThis.val = Integer.parseInt(value.image);}
    | <TRUE> {jjtThis.type = "boolean"; jjtThis.val = true;}
    | <FALSE> {jjtThis.type = "boolean"; jjtThis.val = false;})

    {return jjtThis;}
}

Expression VarReference() #VarReference : {Token id;}
{
    id=<IDENTIFIER>
    {jjtThis.identifier = id.image; return jjtThis;}
}

Expression SelfReference() #SelfReference : {}
{
    <THIS>
    {return jjtThis;}
}

Expression ArrayCreation() #ArrayCreation : {Expression e;}
{
    <INT> <L_SBRACKET> e=Expression() <R_SBRACKET> {jjtThis.size = e;}
    {return jjtThis;}
}

Expression ConstructorCall() #ConstructorCall : {Token identifier;}
{
    identifier=<IDENTIFIER> {jjtThis.identifier = identifier.image;} <L_PAR> <R_PAR>
    {return jjtThis;}
}

Expression Negation() #Negation : {Expression e;}
{
    <NOT> e=Expression()
    {jjtThis.child = e; return jjtThis;}
}

// Equivalent to E'. Used to remove left recursion on Expression()
Expression Expr2(Expression l) #void : {Token identifier; Expression e, e2 = null;}
{
    (e = And(l)
    | e = ArrayAccessExpr(l)
    |   <DOT> (
                e = ArrayLength(l)
                | e = FunctionCall(l)
            ))
    (LOOKAHEAD(2) e2=Expr2(e))?
    // Maybe missing empty string??
    {return e2 == null ? e : e2;}
}

Expression ArrayAccessExpr(Expression l) #ArrayAccess(2) : {Expression e;}
{
    <L_SBRACKET> e=Expression() <R_SBRACKET> {jjtThis.index = e; jjtThis.arrayRef = l;}
    {return jjtThis;}
}


Expression ArrayLength(Expression l) #ArrayLength(1) : {}
{
    <LENGTH> {jjtThis.arrayRef = l;}
    {return jjtThis;}
}

Expression FunctionCall(Expression l) #FunctionCall(2) : {Token identifier;}
{
    identifier=<IDENTIFIER> {jjtThis.identifier = identifier.image;}
                <L_PAR> (( Expression() ( <COMMA> Expression() )* )?) #Parameters  <R_PAR>

    {jjtThis.ownerRef = l;}
    {return jjtThis;}
}

Expression And(Expression l) #void : {Expression r;}
{

    (LOOKAHEAD(2) r = AndExpr(l) | r = LessThan(l)) (LOOKAHEAD(2) r=And(r))?

    {return r;}
}
Expression AndExpr(Expression l) #And(2) : {Expression r;}
{
    <AND> r=ExpressionNoArt() (LOOKAHEAD(2) r=LessThan(r))? {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
    {return jjtThis;}
}


Expression LessThan(Expression l) #void : {Expression r;}
{

    (LOOKAHEAD(2) r=LessThanExpr(l) | r=SumOrSub(l)) (LOOKAHEAD(2) r=LessThan(r))?
    {return r;}
}
Expression LessThanExpr(Expression l) #LessThan(2) : {Expression r;}
{
    <LESS_THAN> r=ExpressionNoArt() (LOOKAHEAD(2) r=SumOrSub(r))? {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
    {return jjtThis;}
}


Expression SumOrSub(Expression l) #void : {Expression r;}
{

    (LOOKAHEAD(2) (
        r=Sum(l)
        | r=Sub(l)) | r=MulOrDiv(l)) (LOOKAHEAD(2) r=SumOrSub(r))?
    {return r;}
}
Expression Sum(Expression l) #Sum(2) : {Expression r;}
{
    <PLUS> r=ExpressionNoArt() (LOOKAHEAD(2) r=MulOrDiv(r))? {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
}
Expression Sub(Expression l) #Sub(2) : {Expression r;}
{
    <MINUS> r=ExpressionNoArt() (LOOKAHEAD(2) r=MulOrDiv(r))? {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
}

Expression MulOrDiv(Expression l) #void : {Expression r;}
{
    (r=Mul(l)
    | r=Div(l)) (LOOKAHEAD(2) r=MulOrDiv(r))?
    {return r;}
}
Expression Mul(Expression l) #Mul(2) : {Expression r;}
{
    <MUL> r=ExpressionNoArt() {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
}
Expression Div(Expression l) #Div(2) : {Expression r;}
{
    <DIV> r=ExpressionNoArt() {jjtThis.left = l; jjtThis.right = r; return jjtThis;}
}

Expression ExpressionNoArt() #void : {Expression e, e2 = null;}
{
    e=Expr1() (LOOKAHEAD(2) e2=Expr2NoArt(e) )?
    {
        return e2 == null ? e : e2;
    }
}

Expression Expr2NoArt(Expression l) #void : {Token identifier; Expression e, e2 = null;}
{
    ( e = ArrayAccessExpr(l)
    |   <DOT> (
                e = ArrayLength(l)
                | e = FunctionCall(l)
            ))
    (LOOKAHEAD(2) e2=Expr2NoArt(e))?
    // Maybe missing empty string??
    {return e2 == null ? e : e2;}
}
