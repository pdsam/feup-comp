options {
  LOOKAHEAD = 1;
}

PARSER_BEGIN(MyGrammar)
    import java.io.InputStream;
    import java.io.FileInputStream;

    // Java code invoking the parser
    public class MyGrammar{
        public static void main(String args[]) throws ParseException {
            if(args.length < 1) {
                System.out.println("Usage: java jmm [-r=<num>] [-o] <input_file.jmm>");
                return;
            } else if (!args[0].matches("(.*).jmm")) {
                System.out.println("Invalid file type: only .jmm files are accepted");
                return;
            }
            InputStream file = null;

            try {
                file = new FileInputStream(args[0]);
            } catch(Exception e) {
                System.out.println(e.getMessage());
                //e.printStackTrace();
                return;
            }

            MyGrammar parser = new MyGrammar(file);
            SimpleNode root = parser.Program();
            root.dump(">");
        }
    }
PARSER_END(MyGrammar)

// Symbols that must be skipped during the lexical analysis
SKIP : 
{
    " "
    | "\t" 
    | "\r"
    | "\n" 
    //skip comments of both types   
    |   <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
    |   <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

// token definition(terminal symbols)
TOKEN : 
{
    <UNDERSCORE: "_" >
    |   <L_SBRACKET: "[" >
    |   <R_SBRACKET: "]" >
    |   <L_BRACKET: "{" >
    |   <R_BRACKET: "}" >
    |   <L_PAR: "(" >
    |   <R_PAR: ")" >
    |   <PLUS: "+" >
    |   <MINUS: "-" >
    |   <MUL: "*" >
    |   <DIV: "/" >
    |   <EQUAL: "=" >
    |   <COMMA : "," >
    |   <DOT : "." >
    |   <NOT : "!" >
    |   <AND : "&&" >
    |   <LESS_THAN : "<" >
    |   <LENGTH : "length" >
    |   <CLASS : "class" >
    |   <THIS : "this" >
    |   <NEW : "new" >
    |   <EXTENDS : "extends" >
    |   <IMPORT : "import" > : IMPORT_STATE
    |   <STRING : "String" >
    |   <PUBLIC : "public" >
    |   <STATIC: "static">
    |   <MAIN: "main">
    |   <VOID: "void">
    |   <INT : "int" >
    |   <BOOL : "boolean" >
    |   <TRUE : "true" >
    |   <FALSE : "false" >
    |   <RETURN : "return" >
    |   <IF : "if" >
    |   <ELSE : "else" >
    |   <WHILE : "while" >
    |   <INTEGER_LITERAL: (<DIGIT>)+ >
    |   <IDENTIFIER: (<LETTER> (<LETTER> | <DIGIT> | <UNDERSCORE>)*) >
    |   <DIGIT: (["0"-"9"]) >
    |   <LETTER: (["a"-"z","A"-"Z"]) >
}

<IMPORT_STATE> TOKEN : {
    <IMPORTED: ((<LETTER>)+ (<DOT> (<LETTER>)+)*) >
}

<IMPORT_STATE, DEFAULT> TOKEN : {
    <SEMICOLON : ";" > : DEFAULT
}

// Production definition
SimpleNode Program() : {}
{
    ImportDeclaration()
    ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration() : { Token imported;}
{
    (<IMPORT> imported=<IMPORTED> {jjtThis.imported = imported;}  <SEMICOLON> )*
}

void ClassDeclaration() : {Token identifier, extended;}
{
    <CLASS> identifier=<IDENTIFIER> {jjtThis.identifier = identifier;}(<EXTENDS> extended=<IDENTIFIER> {jjtThis.extended = extended;})?
    <L_BRACKET>
        (VarDeclaration())*
        (
            LOOKAHEAD(2)
            MethodDeclaration()
        )*
        MainDeclaration()            // This forces 'main' to only appear once
        (MethodDeclaration())*
    <R_BRACKET> 
}

void VarDeclaration() : {Token type, identifier;}
{
    type=Type() {jjtThis.type = type;} identifier=<IDENTIFIER> {jjtThis.identifier = identifier;} <SEMICOLON>
}

void MethodDeclaration() : {Token type, identifier;}
{
    <PUBLIC> type=Type() {jjtThis.type = type;} identifier=<IDENTIFIER> {jjtThis.identifier = identifier;}  <L_PAR> Arguments() <R_PAR>
    <L_BRACKET>
        (
            LOOKAHEAD(2)
            VarDeclaration()
        )*
        (Statement())*
        <RETURN> Expression() <SEMICOLON> // A return statement has to be the last thing in a method declaration
    <R_BRACKET>
}

void MainDeclaration() : {Token identifier;}
{
    <PUBLIC> <STATIC> <VOID> <MAIN> <L_PAR> <STRING> <L_SBRACKET> <R_SBRACKET> identifier=<IDENTIFIER> {jjtThis.identifier = identifier;} <R_PAR>
    <L_BRACKET>
        (LOOKAHEAD(2) VarDeclaration())*
        (Statement())*
    <R_BRACKET>
}

void Arguments() : {}
{
    ( Argument() ( <COMMA> Argument())* )?
}

void Argument() : {Token identifier;}
{
    Type() identifier=<IDENTIFIER> {jjtThis.identifier = identifier;}
}

void Type(): {}
{
    <INT> {jjtThis.type = "int";} (<L_SBRACKET> <R_SBRACKET> {jjtThis.type = "array";} )?
    |   <BOOL> {jjtThis.type = "boolean";}
    |   <IDENTIFIER> {jjtThis.type = "identifier";}
}

void Statement() : { Token identifier;}
{
    <L_BRACKET> (Statement())* <R_BRACKET>
    |   IfElseStmt() {jjtThis.statement = "ifElse";}
    |   WhileStmt() {jjtThis.statement = "while";}
    |   (
            LOOKAHEAD(<IDENTIFIER> <EQUAL>) identifier= <IDENTIFIER> {jjtThis.identifier = identifier;}  <EQUAL> Expression() <SEMICOLON>
            | LOOKAHEAD(<IDENTIFIER> <L_BRACKET> ) IdSub()
            | Expression() <SEMICOLON>
        )
}

void IfElseStmt() : {}
{
    <IF> <L_PAR> Expression() <R_PAR>
        Statement()
    <ELSE>
        Statement()
}

void WhileStmt() : {}
{
    <WHILE> <L_PAR> Expression() <R_PAR>
        Statement()
}

void IdSub() : {Token identifier;} {
    identifier=<IDENTIFIER>{jjtThis.identifier = identifier;} <L_SBRACKET> Expression() <R_SBRACKET> (
    (<EQUAL> Expression() <SEMICOLON>)
    | Expr2()
    )
}

void Expression()  #void : {}
{
    Expr1() (LOOKAHEAD(2) Expr2() )?
}

void Expr1() : {Token identifier, value;} {
    value = <INTEGER_LITERAL> {jjtThis.type = "int"; jjtThis.val = Integer.pasrInt(value.image);} #Literal
    | <TRUE> {jjtThis.type = "boolean"; jjtThis.val = true;} #Literal
    | <FALSE> {jjtThis.type = "boolean"; jjtThis.val = false;} #Literal
    |  identifier= <IDENTIFIER> {jjtThis.identifier = identifier;}
    |   <THIS>
    |   (<NEW>  (
            <INT> <L_SBRACKET> Expression() <R_SBRACKET>
            |  identifier=<IDENTIFIER> {jjtThis.identifier = identifier;} <L_PAR> <R_PAR>
        ))
    |   ( <NOT> Expression() )
    |   ( <L_PAR> Expression() <R_PAR> )
}

// Equivalent to E'. Used to remove left recursion on Expression()
void Expr2() #void : {Token identifier;}
{
    And() |
    ((
        ( <L_SBRACKET> Expression() <R_SBRACKET> )
        |   (<DOT> (
                    <LENGTH>
                    |  identifier=<IDENTIFIER> {jjtThis.identifier = identifier;} <L_PAR> ( Expression() ( <COMMA> Expression() )* )?  <R_PAR>
                )
            )
    ) (LOOKAHEAD(2) Expr2())?)
    // Maybe missing empty string??
}

void And() #void : {} {
    LessThan() (LOOKAHEAD(2) <AND> LessThan() #And(2))?
}

void LessThan() #void : {} {
    SumOrSub() (LOOKAHEAD(2) <LESS_THAN> SumOrSub() #LessThan(2))?
}

void SumOrSub() #void : {} {
    MulOrDiv() (LOOKAHEAD(2) (<PLUS> MulOrDiv() #Sum(2) | <MINUS> MulOrDiv() #Sub(2)) )?
}

void MulOrDiv() : {} {
    (<MUL> Expression() #Mul(2) )
    | (<DIV> Expression() #Div(2) )
}
